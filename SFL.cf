token UIdent (upper (letter | digit | '_')*);

Prog.       Program ::= [Stmt];
ExpStmt.    Stmt ::= Exp;

TypeConstr. TC ::= UIdent [Ident] ;
TypeDecl.   Stmt ::= "type" UIdent [Ident] "=" [TC];
separator nonempty TC "|";



ELam.       Exp ::= Ident "=>" FBody;
Function.   Stmt ::= "def" Ident Ident [Ident] "=" FBody;
FBodyMatch. FBody ::= MatchBody;
FBodyExp.   FBody ::= Exp;

Value.      Stmt ::= "val" Ident "=" Exp;

EMatch.      Exp ::= "match" Exp MatchBody;
MBody.      MatchBody ::= "{" [MatchCase] "}";
MCase.      MatchCase ::= "case" PatExp "=>" Exp;

EIf.        Exp ::= "if" Exp "then" Exp "else" Exp;
ELet.       Exp ::= "let" PatExp "=" Exp "in" Exp;
ELetRec.    Exp ::= "let" "rec" Ident "=" Exp "in" Exp;

PatIdent.   Pat ::= Ident;
PatTCPat.   Pat ::= UIdent [Pat];
PatWild.    Pat ::= "_";

PETuple.    PatExp ::= PatExp "," PatExp1;
PECons.     PatExp1 ::= PatExp1 ":" PatExp2;
PEPat.      PatExp2 ::= Pat;
coercions PatExp 2;

ETuple.     Exp ::= Exp1 "," [Exp1];
ECons.      Exp1 ::= Exp1 ":" Exp2;
EOr.        Exp2 ::= Exp2 "or" Exp3;
EAnd.       Exp3 ::= Exp3 "and" Exp4;
ENot.       Exp4 ::= "not" Exp5;
ELt.        Exp5 ::= Exp5 "<" Exp6;
ELte.       Exp5 ::= Exp5 "<=" Exp6;
EGt.        Exp5 ::= Exp5 ">" Exp6;
EGte.       Exp5 ::= Exp5 ">=" Exp6;
EEq.        Exp5 ::= Exp5 "==" Exp6;
ENEq.       Exp5 ::= Exp5 "/=" Exp6;
EAdd.       Exp6 ::= Exp6 "+" Exp7;
ESub.       Exp6 ::= Exp6 "-" Exp7;
EMul.       Exp7 ::= Exp7 "*" Exp8;
EDiv.       Exp7 ::= Exp7 "/" Exp8;
EMod.       Exp7 ::= Exp7 "%" Exp8;
EApp.       Exp8 ::= Exp8 [Exp9];
EInt.       Exp9 ::= Integer;
ETrue.      Exp9 ::= "True";
EFalse.     Exp9 ::= "False";
EList.      Exp9 ::= "[" [LElem] "]";
EVar.       Exp9 ::= Ident;
ETConstr.   Exp9 ::= UIdent [ETCELem];
coercions Exp 9;

separator   nonempty Exp1 ",";

EListElem.  LElem ::= Exp1;
separator   LElem ",";

ETCElem.    ETCELem ::= Exp1;
separator   ETCELem "";

separator Stmt ";";
separator MatchCase ";";
terminator Ident "";
terminator Pat "";
terminator nonempty Exp9 "";
